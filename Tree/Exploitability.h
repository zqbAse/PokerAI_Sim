#pragma once
#include <iostream>
#include "../Poker/State.h"
#include "Node.h"

using namespace std;
/// <summary>
/// 简化版的游戏状态类来计算可利用度
/// </summary>
class Sim_State {
public:
	int initial_chips;				//每个玩家初始的筹码
	int last_raise, pot, curplayer, foldp;		//last_raise：上个player的raise筹码个数；pot:底池；curplayer：当前需要做动作的玩家id；foldp：-1表示没有玩家fold，0表示玩家0 flod，1表示玩家1 fold
	int rivercluster;			//rivercluster是历史手牌信息，例如rivercluster = 2143表示preflop hole card:2, flop community cards:14, turn community card:3
	int players_betchips, betting_stage;		//players_betchips：被求可利用度的玩家投入筹码数；betting_stage：当前所处的game round,其中0：preflop，1：flop，2：turn
	Sim_State(int big_small_blind) {
		reset_game(big_small_blind);
	}
	void reset_game(int big_small_blind) {
		initial_chips = 400;
		betting_stage = -1;
		foldp = -1;
		last_raise = 50;//every round last raise
		curplayer = 0; //current action player id
		pot = 150;
		rivercluster = -1;
		players_betchips = big_small_blind;
	}
	void reset_betting_round_state() {
		last_raise = 0;
		curplayer = 0;
	}
	void move_to_next_player() {
		curplayer ^= 1;
	}
	void take_action(char actionstr, int playeri) {
		int paychips = 0;
		if (actionstr == 'l') {
			paychips = last_raise;
			last_raise = 0;
		}
		else if (actionstr == 'd')
			foldp = curplayer;
		else if (actionstr == 'n') {
			paychips = last_raise;
			last_raise = initial_chips - (pot + last_raise) / 2;
			paychips += last_raise;
		}
		else {
			cout << "action:" << actionstr << ",not exist the action" << endl;
			throw exception();
		}
		pot += paychips;
		if (curplayer != playeri)
			players_betchips += paychips;
		if (pot > 2 * initial_chips || players_betchips > initial_chips) {
			cout << "pot:" << pot << endl;
			cout << "players_betchips:" << players_betchips << endl;
			throw exception();
		}
		move_to_next_player();
	}
};
Engine engine;
/// <summary>
/// 求解可利用度
/// </summary>
/// <param name="tree">博弈树节点</param>
/// <param name="playeri">playeri求解另一个玩家的可利用度</param>
/// <param name="state">简化版的游戏状态</param>
/// <returns></returns>
double exploit(strategy_node* tree, int playeri, Sim_State state) {
	int ph = state.curplayer;	//轮到ph玩家来采取动作
	if (tree->action_len == 0) {		//到达叶节点
		if (state.pot - state.players_betchips <= 0) {	//判断pot数量是否 > player bet，测试游戏状态是否有bug
			cout << "state.pot - state.players_betchips <= 0:" << state.pot - state.players_betchips << endl;
			throw exception();
		}
		//如果没有玩家fold, 则根据胜率计算期望收益
		if (state.foldp == -1) {
			//如果在preflop有人allin且都call了，除去当前玩家的手牌，然后模拟所有可能的公共牌，计算每个情况下玩家的胜率
			if (state.betting_stage == 0) {
				int mycard = state.rivercluster - 1;		//被求可利用度玩家的手牌
				int community[3];
				int cardshave[card_rule_len];
				int cur = 0;
				//除去当前玩家手牌
				for (int i = 0; i < card_rule_len; i++)
					if (i != mycard)
						cardshave[cur++] = i;
				int id0 = 0, id1 = 0, id2 = 0;
				assert(cur = card_rule_len - 1);
				//模拟所有可能的公共牌，C(5,3) = 10种情况，计算每种情况被求可利用度玩家的胜率
				for (int i = 0; i < cur; i++) {
					for (int j = i + 1; j < cur; j++) {
						for (int k = j + 1; k < cur; k++) {
							community[0] = cardshave[i];
							community[1] = cardshave[j];
							community[2] = cardshave[k];
							int cards[card_rule_len];
							int tempcur = 0;
							for (int t = 0; t < cur; t++)
								if (t != i && t != j && t != k)
									cards[tempcur++] = cardshave[j];
							assert(tempcur == card_rule_len - 4);
							for (int p = 0; p < tempcur; p++) {	//除去当前hole card和假设的community cards再模拟对手可能的手牌
								int mystrength = engine.Maxstrength(mycard, community);
								int oppstrength = engine.Maxstrength(cards[p], community);
								if (mystrength > oppstrength)
									id0++;
								else if (mystrength < oppstrength)
									id1++;
								else if (mystrength == oppstrength)
									id2++;
							}
						}
					}
				}
				double winrate = (id0 + id2 / 2.0) / (id0 + id1 + id2);//id0赢的次数，id1输的次数，id2平局次数，那么期望胜率为 （赢+平局/2）/ 总次数
				return winrate * state.pot - state.players_betchips;	//期望赢得筹码-投入的筹码 = 期望收益
			}
			//如果在flop有人allin且都call了，除去当前玩家的手牌，然后模拟所有可能的公共牌，计算每个情况下玩家的胜率
			else if(state.betting_stage == 1) {
				int mycard = state.rivercluster / cardlen2 - 1;	//被求可利用度玩家的手牌
				int c1 = (state.rivercluster % cardlen2) / cardlen1 - 1, c2 = (state.rivercluster % cardlen1) - 1;//c1,c2为flop两张公共牌
				int community[3] = { c1,c2 };
				int cardshave[card_rule_len];
				int cur = 0;
				//除去当前玩家手牌和flop community cards的手牌
				for (int i = 0; i < card_rule_len; i++)
					if (i != mycard && i != c1 && i != c2)
						cardshave[cur++] = i;
				int id0 = 0, id1 = 0, id2 = 0;
				assert(cur = card_rule_len - 3);
				//模拟所有可能公共牌，C(3,1) = 3，计算每种情况被求可利用度玩家的胜率
				for (int i = 0; i < cur; i++) {
					community[2] = cardshave[i];
					int cards[card_rule_len];
					int tempcur = 0;
					for (int j = 0; j < cur; j++)
						if (i != j)
							cards[tempcur++] = cardshave[j];
					assert(tempcur == card_rule_len - 4);
					for (int j = 0; j < tempcur; j++) {		//除去当前hole card和假设的community cards再模拟对手可能的手牌
						int mystrength = engine.Maxstrength(mycard, community);
						int oppstrength = engine.Maxstrength(cards[j], community);
						if (mystrength > oppstrength)
							id0++;
						else if (mystrength < oppstrength)
							id1++;
						else if (mystrength == oppstrength)
							id2++;
					}
				}
				double winrate = (id0 + id2 / 2.0) / (id0 + id1 + id2);	//id0赢的次数，id1输的次数，id2平局次数，那么期望胜率为 （赢+平局/2）/ 总次数
				return winrate * state.pot - state.players_betchips;	//期望赢得筹码-投入的筹码 = 期望收益
			}
			//如果在turn有人allin且都call了，除去当前玩家的手牌和公共牌，然后模拟所有对手可能出现的手牌，计算每个情况下玩家的胜率
			else if (state.betting_stage == 2) {
				int mycard = state.rivercluster / cardlen3 - 1;		//被求可利用度玩家的手牌
				int c1 = (state.rivercluster % cardlen3) / cardlen2 - 1, c2 = (state.rivercluster % cardlen2) / cardlen1 - 1,c3 = state.rivercluster % cardlen1 - 1;//c1,c2为flop两张公共牌,c3为turn公共牌
				int community[3] = { c1,c2,c3 };
				int cards[card_rule_len];
				int cur = 0;
				//除去当前玩家手牌和community cards的手牌
				for (int i = 0; i < card_rule_len; i++) 
					if (i != mycard && i != c1 && i != c2 && i != c3) 
						cards[cur++] = i;

				int id0 = 0, id1 = 0, id2 = 0;
				assert(cur = card_rule_len - 4);
				for (int i = 0; i < cur; i++) {		//除去当前hole card和community cards再模拟对手可能的手牌
					int mystrength = engine.Maxstrength(mycard, community);
					int oppstrength = engine.Maxstrength(cards[i], community);
					if (mystrength > oppstrength)
						id0++;
					else if (mystrength < oppstrength)
						id1++;
					else if (mystrength == oppstrength)
						id2++;
				}
				double winrate = (id0 + id2 / 2.0) / (id0 + id1 + id2);//id0赢的次数，id1输的次数，id2平局次数，那么期望胜率为 （赢+平局/2）/ 总次数
				return winrate * state.pot - state.players_betchips;	//期望赢得筹码-投入的筹码 = 期望收益
			}
		}
		//如果有玩家fold，fold玩家输掉全部bet chips。
		//state.foldp表示哪个玩家fold，如果fold的玩家id 是 被求可利用度的玩家，它输掉所有bet chips，如果fold玩家是求对手的可利用度玩家，则被求可利用度玩家赢全部pot
		else
			return state.foldp != playeri ? -state.players_betchips : state.pot - state.players_betchips; //one person fold
	}
	else if (tree->chanced) {//当前节点是否为chance node
		double vo = 0;
		if (state.last_raise == 0)			//prelop初始情况 大盲投100，小盲投50 则相当last raise=50，不重置游戏状态
			state.reset_betting_round_state();
		for (int i = 0; i < tree->action_len; i++) {		//chance node best response is equal to expect of child node best response
			strategy_node* newnode = (tree->actions + i);
			Sim_State newstate = state;
			newstate.betting_stage++;			//到达chance node则game round 需要 +1
			newstate.rivercluster = tree->actions[i].chancempde_cards;		//chancempde_cards是历史手牌信息，例如chancempde_cards = 2143表示preflop hole card:2, flop community cards:14, turn community card:3
			double voa = exploit(newnode, playeri, newstate);//累计child noed 的best response求平均
			vo += voa;
		}
		return vo / tree->action_len;
	}
	else if (ph == playeri) {	//当前节点是求对手可利用度的玩家，它选择 max best response
		double vo = 100000;
		double sigma[6];
		calculate_strategy(tree->regret, tree->action_len, sigma);//根据当前节点的后悔值获得玩家当前的策略sigma[a]
		for (int i = 0; i < tree->action_len; i++) {
			strategy_node* newnode = (tree->actions + i);
			Sim_State newstate = state;
			newstate.take_action(tree->actionstr[i], playeri);		//执行第i个动作
			double voa = exploit(newnode, playeri, newstate);		//求子节点可利用度
			if (vo > voa)					//max best response as the current exploitability
				vo = voa;	
		}

		tree->bestresponse = vo;		//the exploitability of the current node
		return vo;
	}
	else {				//当前节点是被求对手可利用度的玩家，它选择 expected value
		double sigma[6];
		double vo = 0;
		calculate_strategy(tree->regret, tree->action_len, sigma);//根据当前节点的后悔值获得玩家当前的策略sigma[a]
		for (int i = 0; i < tree->action_len; i++) {
			strategy_node* newnode = (tree->actions + i);
			Sim_State newstate = state;
			newstate.take_action(tree->actionstr[i], playeri);//执行第i个动作
			double voa = exploit(newnode, playeri, newstate);//求子节点可利用度
			vo += voa * sigma[i];			//可利用度的期望
		}
		tree->bestresponse = vo;//the exploitability of the current node
		return vo;
	}
}