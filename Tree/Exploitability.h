#pragma once
#include <iostream>
#include "../Poker/State.h"
#include "Node.h"

using namespace std;

Engine engine;
inline float findmax(double a[], int len) {
	int idx = 0;
	float maxval = a[0];
	for (int i = 1; i < len; i++)
		if (a[i] > maxval)
			maxval = a[i];
	return maxval;
}
inline float expectval(double cfvs[], double regrets[], int len) {
	double sigma[12];
	calculate_strategy(regrets, len, sigma);
	double cfv = 0;
	for (int i = 0; i < len; i++)
		cfv += cfvs[i] * sigma[i];
	return cfv;
}

/// <summary>
/// 求解可利用度
/// </summary>
/// <param name="tree">博弈树节点</param>
/// <param name="playeri">playeri求解另一个玩家的可利用度</param>
/// <param name="state">简化版的游戏状态</param>
/// <returns></returns>
void exploit(strategy_node* tree[6], int playeri, LeducPokerstate state, double range[6], double actionicfvs1[6], int oppcard, int len) {
	int ph = state.player_i_index;	//轮到ph玩家来采取动作
	if (state.is_terminal()) {		//到达叶节点
		if (state.table.total_pot - state.table.players[0].n_bet_chips() <= 0) {	//判断pot数量是否 > player bet，测试游戏状态是否有bug
			cout << "state.pot - state.players_betchips <= 0:" << state.table.total_pot - state.table.players[0].n_bet_chips() << endl;
			throw exception();
		}
		//如果没有玩家fold, 则根据胜率计算期望收益
		if (state.betting_stage != 3) {
			//如果在preflop有人allin且都call了，除去当前玩家的手牌，然后模拟所有可能的公共牌，计算每个情况下玩家的胜率
			if (state.betting_stage == 4) {
				//double ans = 0;
				//for (int t = 0; t < len; t++)
				//	ans += range[t];
				bool vis[10] = { false };
				vis[oppcard] = true;
				for (int t = 0; t < len; t++) {
					if (vis[t] || range[t] == 0) {
						actionicfvs1[t] = 0;
						continue;
					}
					int mycard = t;		//被求可利用度玩家的手牌
					vis[t] = true;

					int id0 = 0, id1 = 0, id2 = 0;
					//模拟所有可能公共牌，C(3,1) = 3，计算每种情况被求可利用度玩家的胜率
					for (int i = 0; i < len; i++) {
						if (!vis[i]) {
							int mystrength = engine.Maxstrength(mycard, i);
							int oppstrength = engine.Maxstrength(oppcard, i);
							if (mystrength > oppstrength)
								id0++;
							else if (mystrength < oppstrength)
								id1++;
							else if (mystrength == oppstrength)
								id2++;
						}
					}
					vis[t] = false;
					double winrate = (id0 + id2 / 2.0) / (id0 + id1 + id2);	//id0赢的次数，id1输的次数，id2平局次数，那么期望胜率为 （赢+平局/2）/ 总次数
					actionicfvs1[t] = -(winrate - 0.5) * state.table.total_pot;//期望赢得筹码-投入的筹码 = 期望收益
					assert(!isnan(actionicfvs1[t]));
				}
			}
			//如果在turn有人allin且都call了，除去当前玩家的手牌和公共牌，然后模拟所有对手可能出现的手牌，计算每个情况下玩家的胜率
			else if (state.betting_stage == 2) {
				//double ans = 0;
				//for (int t = 0; t < card_rule_len; t++)
				//	ans += range[t];
				int c1 = state.table.community_cards.eval_card;//c1公共牌
				bool vis[10] = { false };
				vis[c1] = vis[oppcard] = true;
				for (int t = 0; t < card_rule_len; t++) {
					if (vis[t] || range[t] == 0) {
						actionicfvs1[t] = 0;
						continue;
					}
					int mycard = t;		//被求可利用度玩家的手牌

					double winrate;
					int mystrength = engine.Maxstrength(mycard, c1);
					int oppstrength = engine.Maxstrength(oppcard, c1);
					if (mystrength > oppstrength)
						winrate = 1;
					else if (mystrength < oppstrength)
						winrate = 0;
					else if (mystrength == oppstrength)
						winrate = 0.5;
					actionicfvs1[t] = -(winrate - 0.5) * state.table.total_pot;//期望赢得筹码-投入的筹码 = 期望收益
					assert(!isnan(actionicfvs1[t]));
				}
			}
			else
				throw exception();
			return;
		}
		//如果有玩家fold，fold玩家输掉全部bet chips。
		//state.foldp表示哪个玩家fold，如果fold的玩家id 是 被求可利用度的玩家，它输掉所有bet chips，如果fold玩家是求对手的可利用度玩家，则被求可利用度玩家赢全部pot
		else {//one person fold
			if (state.table.players[playeri].active)
				for (int i = 0; i < len; i++) {
					if (range[i] != 0)
						actionicfvs1[i] = state.table.players[playeri ^ 1].n_bet_chips();
					else
						actionicfvs1[i] = 0;
				}
			else
				for (int i = 0; i < len; i++) {
					if (range[i] != 0)
						actionicfvs1[i] = -state.table.players[playeri].n_bet_chips();
					else
						actionicfvs1[i] = 0;
				}
			return;
		}
	}
	strategy_node* tempprivatenode[10];
	char legal_actionstr[10];
	state.legal_actions(legal_actionstr);
	int lena = strlen(legal_actionstr);
	double cfv[6][6];
	memset(cfv, 0, sizeof cfv);
	for (int i = 0; i < lena; i++) {
		LeducPokerstate newstate = state;
		bool is_chance = newstate.take_action(legal_actionstr[i]);
		if (is_chance) {
			int chancelen;
			strategy_node* tempprivatenode2[10];
			double tempactionicfv1[10];
			double actionipro[10];
			if (state.player_i_index != playeri) {
				for (int j = 0; j < len; j++) {
					actionipro[j] = 0;
					if (range[j] != 0) {
						double tmp = calculate_strategy(tree[j]->ave_strategy, tree[j]->action_len, i);
						actionipro[j] = range[j] * tmp;
					}
				}
			}
			else {
				for (int j = 0; j < len; j++)
					actionipro[j] = range[j];
			}
			if (state.betting_stage == 0) {
				int testadd[10];
				memset(testadd, 0, sizeof testadd);
				bool vis[10] = { false };
				vis[oppcard] = true;
				for (int p = 0; p < len; p++) {
					if (!vis[p]) {
						vis[p] = true;
						double temprange[10];
						for (int k = 0; k < len; k++) {
							if (!vis[k]) {
								tempprivatenode2[k] = tree[k]->actions[i].actions + p;
								temprange[k] = actionipro[k];

							}
							else
								tempprivatenode2[k] = NULL, temprange[k] = 0;
						}
						newstate.table.community_cards.eval_card = p; memset(tempactionicfv1, 0, sizeof tempactionicfv1);
						exploit(tempprivatenode2, playeri, newstate, temprange, tempactionicfv1, oppcard, 6);
						for (int k = 0; k < len; k++) {
							if (!vis[k]) {
								cfv[i][k] += tempactionicfv1[k] / 4.0;
								testadd[k]++;
							}
						}
						vis[p] = false;
					}
				}
				for (int k = 0; k < len; k++)
					if (!vis[k])
						assert(testadd[k] == 4);
			}
			else
				throw exception();
		}
		else {
			for (int j = 0; j < len; j++)
				if (tree[j] != NULL)
					tempprivatenode[j] = tree[j]->actions + i;
				else
					tempprivatenode[j] = NULL;
			if (state.player_i_index != playeri) {
				double actionipro[10];
				for (int j = 0; j < len; j++) {
					actionipro[j] = 0;
					if (range[j] != 0) {
						double tmp = calculate_strategy(tree[j]->ave_strategy, tree[j]->action_len, i);
						actionipro[j] = range[j] * tmp;
					}
				}
				exploit(tempprivatenode, playeri, newstate, actionipro, cfv[i], oppcard, len);
			}
			else
				exploit(tempprivatenode, playeri, newstate, range, cfv[i], oppcard, len);

		}
	}
	if (state.player_i_index == playeri) {
		double cfvs[12];
		int selfc = playeri ^ 1;
		memset(cfvs, 0, sizeof cfvs);
		double ans = range[0];
		for (int i = 1; i < len; i++)
			ans += range[i];

		for (int j = 0; j < len; j++)
			if (range[j] > 0.00000000001) {

				double temp = range[j] / ans;
				for (int k = 0; k < tree[j]->action_len; k++)
					cfvs[k] += temp * cfv[k][j];
			}
		int index = 0;
		for (int k = 1; k < lena; k++)
			if (cfvs[index] < cfvs[k])
				index = k;
		for (int j = 0; j < len; j++)
			actionicfvs1[j] = cfv[index][j];
	}
	else
		for (int j = 0; j < len; j++) {
			if (range[j] > 0.00000000001) {
				double sigma[12];
				calculate_strategy(tree[j]->ave_strategy, tree[j]->action_len, sigma);
				double val = 0;
				for (int i = 0; i < tree[j]->action_len; i++)
					val += cfv[i][j] * sigma[i];
				actionicfvs1[j] = val;
			}
			else
				actionicfvs1[j] = 0;
			assert(!isnan(actionicfvs1[j]));
		}
}
