#pragma once
#include <iostream>
#include "../Poker/State.h"
#include "Node.h"

using namespace std;

Engine engine;
double exploit(strategy_node* tree, int playeri, Sim_State state) {
	int ph = state.curplayer;
	if (tree->action_len == 0) {
		if (state.pot - state.players_betchips <= 0) {
			cout << "state.pot - state.players_betchips <= 0:" << state.pot - state.players_betchips << endl;
			throw exception();
		}
		if (state.foldp == -1) {
			if (state.betting_stage == 0) {
				int mycard = state.rivercluster - 1;
				int community[3];
				int cardshave[card_rule_len];
				int cur = 0;
				for (int i = 0; i < card_rule_len; i++)
					if (i != mycard)
						cardshave[cur++] = i;
				int id0 = 0, id1 = 0, id2 = 0;
				assert(cur = card_rule_len - 1);
				for (int i = 0; i < cur; i++) {
					for (int j = i + 1; j < cur; j++) {
						for (int k = j + 1; k < cur; k++) {
							community[0] = cardshave[i];
							community[1] = cardshave[j];
							community[2] = cardshave[k];
							int cards[card_rule_len];
							int tempcur = 0;
							for (int t = 0; t < cur; t++)
								if (t != i && t != j && t != k)
									cards[tempcur++] = cardshave[j];
							assert(tempcur == card_rule_len - 4);
							for (int p = 0; p < tempcur; p++) {
								int mystrength = engine.Maxstrength(mycard, community);
								int oppstrength = engine.Maxstrength(cards[p], community);
								if (mystrength > oppstrength)
									id0++;
								else if (mystrength < oppstrength)
									id1++;
								else if (mystrength == oppstrength)
									id2++;
							}
						}
					}
				}
				double winrate = (id0 + id2 / 2.0) / (id0 + id1 + id2);
				return winrate * state.pot - state.players_betchips;
			}
			else if(state.betting_stage == 1) {
				int mycard = state.rivercluster / cardlen2 - 1;
				int c1 = (state.rivercluster % cardlen2) / cardlen1 - 1, c2 = (state.rivercluster % cardlen1) - 1;
				int community[3] = { c1,c2 };
				int cardshave[card_rule_len];
				int cur = 0;
				for (int i = 0; i < card_rule_len; i++)
					if (i != mycard && i != c1 && i != c2)
						cardshave[cur++] = i;
				int id0 = 0, id1 = 0, id2 = 0;
				assert(cur = card_rule_len - 3);
				for (int i = 0; i < cur; i++) {
					community[2] = cardshave[i];
					int cards[card_rule_len];
					int tempcur = 0;
					for (int j = 0; j < cur; j++)
						if (i != j)
							cards[tempcur++] = cardshave[j];
					assert(tempcur == card_rule_len - 4);
					for (int j = 0; j < tempcur; j++) {
						int mystrength = engine.Maxstrength(mycard, community);
						int oppstrength = engine.Maxstrength(cards[j], community);
						if (mystrength > oppstrength)
							id0++;
						else if (mystrength < oppstrength)
							id1++;
						else if (mystrength == oppstrength)
							id2++;
					}
				}
				double winrate = (id0 + id2 / 2.0) / (id0 + id1 + id2);
				return winrate * state.pot - state.players_betchips;
			}
			else if (state.betting_stage == 2) {
				int mycard = state.rivercluster / cardlen3 - 1;
				int c1 = (state.rivercluster % cardlen3) / cardlen2 - 1, c2 = (state.rivercluster % cardlen2) / cardlen1 - 1,c3 = state.rivercluster % cardlen1 - 1;
				int community[3] = { c1,c2,c3 };
				int cards[card_rule_len];
				int cur = 0;
				for (int i = 0; i < card_rule_len; i++) 
					if (i != mycard && i != c1 && i != c2 && i != c3) 
						cards[cur++] = i;
				int id0 = 0, id1 = 0, id2 = 0;
				assert(cur = card_rule_len - 4);
				for (int i = 0; i < cur; i++) {
					int mystrength = engine.Maxstrength(mycard, community);
					int oppstrength = engine.Maxstrength(cards[i], community);
					if (mystrength > oppstrength)
						id0++;
					else if (mystrength < oppstrength)
						id1++;
					else if (mystrength == oppstrength)
						id2++;
				}
				double winrate = (id0 + id2 / 2.0) / (id0 + id1 + id2);
				return winrate * state.pot - state.players_betchips;
			}
		}
		else
			return state.foldp != playeri ? -state.players_betchips : state.pot - state.players_betchips; //one person fold
	}
	else if (tree->chanced) {//assert node correct
		//double sigma[201];
		double vo = 0;
		if (state.last_raise == 0)
			state.reset_betting_round_state();
		//calculate_strategy(tree->regret, tree->action_len, sigma);
		for (int i = 0; i < tree->action_len; i++) {
			strategy_node* newnode = (tree->actions + i);
			Sim_State newstate = state;
			newstate.betting_stage++;
			newstate.rivercluster = tree->actions[i].chancempde_cards;
			double voa = exploit(newnode, playeri, newstate);
			vo += voa;
		}
		return vo / tree->action_len;
	}
	else if (ph == playeri) {
		double vo = 100000;
		double sigma[6];
		double cfv = 0;
		calculate_strategy(tree->regret, tree->action_len, sigma);
		for (int i = 0; i < tree->action_len; i++) {
			strategy_node* newnode = (tree->actions + i);
			Sim_State newstate = state;
			newstate.take_action(tree->actionstr[i], playeri);
			double voa = exploit(newnode, playeri, newstate);
			if (vo > voa)
				vo = voa;
		}

		tree->bestresponse = vo;
		return vo;
	}
	else {
		double sigma[6];
		double vo = 0;
		calculate_strategy(tree->regret, tree->action_len, sigma);
		for (int i = 0; i < tree->action_len; i++) {
			strategy_node* newnode = (tree->actions + i);
			Sim_State newstate = state;
			newstate.take_action(tree->actionstr[i], playeri);
			double voa = exploit(newnode, playeri, newstate);
			vo += voa * sigma[i];
		}
		tree->bestresponse = vo;
		return vo;
	}
}
double exploit(strategy_node* tree, int playeri, Pokerstate state) {
	int ph = state.player_i_index;
	if (tree->action_len == 0) {
		if (state.betting_stage == 5)
			return state.table.players[playeri ^ 0].n_chips - state.table.players[playeri ^ 0].initial_chips; //one person fold
		else if (state.betting_stage > 0)
			return state.table.players[playeri ^ 0].clusters[state.betting_stage] / 200.0 * state.table.total() - state.table.players[playeri ^ 0].n_bet_chips(); // win expected chips - bet chips
		else
			return 0;
	}
	else if (tree->action_len > 10) {//assert node correct
		if (state.table.total() - state.table.players[playeri ^ 0].n_bet_chips() <= 0) {
			cout << "state.pot - state.oppplayeri_betchips <= 0:" << state.table.total() - state.table.players[playeri ^ 0].n_bet_chips() << endl;
			throw exception();
		}
		double vo = 0;
		int tpnum = 0;
		if (state.last_raise == 0)
			state.reset_betting_round_state();
		for (int i = 0; i < tree->action_len; i++) {
			strategy_node* newnode = (tree->actions + i);
			if (newnode->action_len > 0) {
				Pokerstate newstate = state;
				newstate.table.players[playeri ^ 0].clusters[state.betting_stage] = i;
				vo += exploit(newnode, playeri, newstate);
				tpnum++;
			}
		}
		vo /= tpnum;
		return vo;
	}
	else if (ph == playeri) {
		if (state.table.total() - state.table.players[playeri ^ 0].n_bet_chips() <= 0) {
			cout << "state.pot - state.oppplayeri_betchips <= 0:" << state.table.total() - state.table.players[playeri ^ 0].n_bet_chips() << endl;
			throw exception();
		}
		double vo = 100000;
		char legal_acts[7];
		state.legal_actions(legal_acts);
		if (strlen(legal_acts) != tree->action_len) {
			cout << "strlen(legal_acts) != tree->action_len:" << strlen(legal_acts)<<","<< tree->action_len << endl;
			throw exception();
		}
		for (int i = 0; i < tree->action_len; i++) {
			strategy_node* newnode = (tree->actions + i);
			Pokerstate newstate = state;
			newstate.apply_action(tree->actionstr[i]);
			double voa = exploit(newnode, playeri, newstate);
			if (vo > voa)
				vo = voa;
		}
		return vo;
	}
	else {
		if (state.table.total() - state.table.players[playeri ^ 0].n_bet_chips() <= 0) {
			cout << "state.pot - state.oppplayeri_betchips <= 0:" << state.table.total() - state.table.players[playeri ^ 0].n_bet_chips() << endl;
			throw exception();
		}
		double sigma[6];
		double vo = 0;
		calculate_strategy(tree->regret, tree->action_len, sigma);
		char legal_acts[7];
		state.legal_actions(legal_acts);
		if (strlen(legal_acts) != tree->action_len) {
			cout << "strlen(legal_acts) != tree->action_len:" << strlen(legal_acts) << "," << tree->action_len << endl;
			throw exception();
		}
		for (int i = 0; i < tree->action_len; i++) {
			strategy_node* newnode = (tree->actions + i);
			Pokerstate newstate = state;
			newstate.apply_action(tree->actionstr[i]);
			double voa = exploit(newnode, playeri, newstate);
			vo += voa * sigma[i];
		}
		return vo;
	}
}